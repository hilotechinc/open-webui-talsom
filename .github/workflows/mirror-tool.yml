name: Mirror Multiple OSS Images to Talsom GHCR
on:
  schedule:
    - cron: "0 2 * * *"   # daily 04:00 UTC
  workflow_dispatch:
concurrency:
  group: mirror-oss
  cancel-in-progress: false
jobs:
  mirror:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        include:
          # GHCR → Hilo Tech GHCR
          - upstream: ghcr.io/hilotechinc/open-webui-custom
            target:   ghcr.io/talsommtl/open-webui-custom
            tag_regex: '^(.*)$'
            tag_exclude_regex: 'cuda|ollama|slim|cache|dev|git|v'
    env:
      UPSTREAM: ${{ matrix.upstream }}
      TARGET:   ${{ matrix.target }}
      TAG_REGEX: ${{ matrix.tag_regex }}
      TAG_EXCLUDE_REGEX: ${{ matrix.tag_exclude_regex || '' }}
      # Tags that are mutable and must be refreshed if their digest changes
      MUTABLE_TAG_REGEX: '^(latest|main)$'
    steps:
      - name: Install skopeo + jq + python3
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo jq python3
      - name: Fetch upstream tags (filtered)
        shell: bash
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN:    ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          set -euo pipefail
          SRC_LIST_CREDS=()
          if [[ "$UPSTREAM" == docker.io/* && -n "${DOCKERHUB_USERNAME:-}" && -n "${DOCKERHUB_TOKEN:-}" ]]; then
            SRC_LIST_CREDS=( --creds "${DOCKERHUB_USERNAME}:${DOCKERHUB_TOKEN}" )
          fi
          echo "[INFO] Fetching tags from ${UPSTREAM}"
          if ! skopeo list-tags docker://${UPSTREAM} "${SRC_LIST_CREDS[@]}" >/tmp/up.json 2>/tmp/up.err; then
            echo "[WARN] Could not list tags for ${UPSTREAM}; skipping. Details:" >&2
            cat /tmp/up.err >&2 || true
            : > selected-tags.txt
          else
            # Extract, include-filter, optional exclude-filter, then sort/dedupe.
            jq -r '.Tags[]' /tmp/up.json > /tmp/all-tags.txt
            if ! grep -E "${TAG_REGEX}" /tmp/all-tags.txt > /tmp/filtered-tags.txt; then
              : > /tmp/filtered-tags.txt
            fi
            if [[ -n "${TAG_EXCLUDE_REGEX}" ]]; then
              if ! grep -Ev "${TAG_EXCLUDE_REGEX}" /tmp/filtered-tags.txt > /tmp/filtered-tags2.txt; then
                : > /tmp/filtered-tags2.txt
              fi
              mv /tmp/filtered-tags2.txt /tmp/filtered-tags.txt
            fi
            sort -uV /tmp/filtered-tags.txt > selected-tags.txt || : > selected-tags.txt
          fi
          echo "[INFO] Filtered upstream tags to mirror:"
          cat selected-tags.txt || true
      - name: Fetch target tags (GHCR)
        shell: bash
        run: |
          set -euo pipefail
          echo "[INFO] Fetching existing tags from ${TARGET}"
          if ! skopeo list-tags docker://${TARGET} \
            --creds "${GITHUB_ACTOR}:${{ secrets.GITHUB_TOKEN }}" >/tmp/tgt.json 2>/tmp/tgt.err; then
            echo "[INFO] Target package may be new; continuing."
            : > target-tags.txt
          else
            jq -r '.Tags[]' /tmp/tgt.json | sort -u > target-tags.txt || true
          fi
          echo "[INFO] Existing tags in target:"
          cat target-tags.txt || true
      - name: Build normalized target version set (for dedupe across v/non-v)
        shell: bash
        run: |
          set -euo pipefail
          grep -E '^[v]?[0-9]+(\.[0-9]+){1,3}$' target-tags.txt | sed -E 's/^v//' | sort -u > target-versions-norm.txt || true
          echo "[INFO] Normalized numeric versions present on target:"
          cat target-versions-norm.txt || true
      - name: Mirror new and updated tags (multi-arch, digest-aware for latest/main) with robust retries
        shell: bash
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN:    ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          set -euo pipefail
          # Source auth
          SRC_COPY_AUTH=()
          SRC_INSPECT_CREDS=()
          if [[ "$UPSTREAM" == docker.io/* && -n "${DOCKERHUB_USERNAME:-}" && -n "${DOCKERHUB_TOKEN:-}" ]]; then
            SRC_COPY_AUTH=( --src-creds "${DOCKERHUB_USERNAME}:${DOCKERHUB_TOKEN}" )
            SRC_INSPECT_CREDS=( --creds "${DOCKERHUB_USERNAME}:${DOCKERHUB_TOKEN}" )
          fi
          # Destination (GHCR): workflow actor + GITHUB_TOKEN
          DEST_COPY_AUTH=( --dest-creds "${GITHUB_ACTOR}:${{ secrets.GITHUB_TOKEN }}" )
          DEST_INSPECT_CREDS=( --creds "${GITHUB_ACTOR}:${{ secrets.GITHUB_TOKEN }}" )
          copy_tag () {
            local tag="$1"
            local max_attempts=5
            local delay=5
            local attempt
            for attempt in $(seq 1 $max_attempts); do
              echo "[INFO] Copying ${UPSTREAM}:${tag} → ${TARGET}:${tag} (attempt ${attempt}/${max_attempts})"
              if skopeo copy \
                "${SRC_COPY_AUTH[@]}" \
                "${DEST_COPY_AUTH[@]}" \
                --format oci \
                --all \
                --retry-times 3 \
                docker://${UPSTREAM}:${tag} \
                docker://${TARGET}:${tag}; then
                return 0
              fi
              echo "[WARN] Copy attempt ${attempt} failed for ${UPSTREAM}:${tag}. Retrying in ${delay}s ..."
              sleep "${delay}"
              delay=$((delay*2))
            done
            echo "[ERROR] Failed to copy ${UPSTREAM}:${tag} after ${max_attempts} attempts."
            return 1
          }
          is_mutable () {
            [[ "$1" =~ ${MUTABLE_TAG_REGEX} ]]
          }
          is_numeric_tag () {
            [[ "$1" =~ ^v?[0-9]+(\.[0-9]+){1,3}$ ]]
          }
          # Track normalized numeric versions we mirror within this run to avoid pushing both vX.Y.Z and X.Y.Z
          declare -A SEEN_NORM=()
          while read -r n; do
            [[ -n "$n" ]] && SEEN_NORM["$n"]=1
          done < target-versions-norm.txt
          NEW_OR_UPDATED=0
          while read -r tag; do
            [[ -z "$tag" ]] && continue
            if is_mutable "$tag"; then
              SRC_DIGEST=$(skopeo inspect "${SRC_INSPECT_CREDS[@]}" --retry-times 3 docker://${UPSTREAM}:${tag} | jq -r '.Digest' || echo "")
              TGT_DIGEST=$(skopeo inspect "${DEST_INSPECT_CREDS[@]}" --retry-times 3 docker://${TARGET}:${tag} 2>/dev/null | jq -r '.Digest' || echo "")
              if [[ -z "$SRC_DIGEST" ]]; then
                echo "[WARN] Could not resolve digest for source ${UPSTREAM}:${tag}; skipping."
                continue
              fi
              if [[ "$SRC_DIGEST" != "$TGT_DIGEST" ]]; then
                echo "[INFO] Mutable tag ${tag} changed (src=${SRC_DIGEST}, tgt=${TGT_DIGEST:-<none>}). Updating…"
                copy_tag "$tag"
                NEW_OR_UPDATED=$((NEW_OR_UPDATED+1))
              else
                echo "[INFO] Mutable tag ${tag} is up-to-date (digest match)."
              fi
            elif is_numeric_tag "$tag"; then
              norm="${tag#v}"
              if [[ -n "${SEEN_NORM[$norm]:-}" ]]; then
                echo "[INFO] Numeric version ${tag} (norm=${norm}) already mirrored/present; skipping."
              else
                echo "[INFO] New numeric version ${tag} (norm=${norm}); mirroring…"
                copy_tag "$tag"
                NEW_OR_UPDATED=$((NEW_OR_UPDATED+1))
                SEEN_NORM["$norm"]=1
                echo "$norm" >> target-versions-norm.txt
              fi
            else
              if grep -q "^${tag}$" target-tags.txt 2>/dev/null; then
                echo "[INFO] Tag ${tag} already present; skipping."
              else
                echo "[INFO] New tag ${tag}; mirroring…"
                copy_tag "$tag"
                NEW_OR_UPDATED=$((NEW_OR_UPDATED+1))
              fi
            fi
          done < selected-tags.txt
          echo "[INFO] Mirrored ${NEW_OR_UPDATED} tag(s)."
